/*
 * This source file was generated by the Gradle 'init' task
 */
package com.example.consoleExample;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.IOException;
import static java.lang.System.exit;
import java.net.ServerSocket;
import java.net.SocketTimeoutException;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.cli.*;
import com.example.consoleExample.Threads.*;
import com.google.errorprone.annotations.concurrent.GuardedBy;
import java.util.Calendar;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.DelayQueue;




public class App {
  static Gson gson = new GsonBuilder().setPrettyPrinting().create();
  static Scanner scan = new Scanner(System.in);
  static JsonActions jAct = new JsonActions();
  @GuardedBy("this")
  private static int reservations = 0;
  public static final long startTime = Calendar.getInstance().getTimeInMillis();
    
    
    
  public static void main(String[] args) throws IOException {
  //--------------------- initializing variables -----------------------------//
    AppConfig config = new AppConfig();
    Options options = config.configureOptions();
    config.optionsExecution(options, args);
    ExecutorService exec = Executors.newCachedThreadPool();
    Integer port = 7777;
    ServerSocket serverSocket = new ServerSocket(port);
    serverSocket.setSoTimeout(15000);
    
    Runnable startServer = () -> {
      while (true) {
      try {
      
      System.out.println(Calendar.getInstance().getTimeInMillis() - startTime + "waiting for connection");
      exec.submit(new ServerThread(port, serverSocket, serverSocket.accept()));
      --reservations;
      
      } catch (SocketTimeoutException ex) {
        if (reservations <= 0 ) {
        System.out.println(Calendar.getInstance().getTimeInMillis()- startTime + "no new connection attempts detected in last 30 seconds\n"
                + "shutting down the server");
        try {
          serverSocket.close();
          break;
        } catch (IOException ex1) {
          Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex1);
          exit(1);
        } 
        }else System.out.println(Calendar.getInstance().getTimeInMillis()- startTime + "tried to close server because of timeout. reservations != 0");

      } catch (IOException ex) {
        Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
      }
      }
    };

    Callable<String> callableTask = () -> {
      TimeUnit.MILLISECONDS.sleep(20);
      return "callable task done";
    };

  //------------------------ running program ---------------------------------//
    

    Future<?> runningServer = exec.submit(startServer);
    
    for (int i = 0; i < 5; i++){
      try {
        TimeUnit.MILLISECONDS.sleep(30); //doesn't work without waiting a bit
        exec.submit(new ClientThread(port, i));
        ++reservations;
      } catch (InterruptedException ex) {
        Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
      }
    }
    //TODO fix overlapping threads
    
    
    try {
      //exec.invokeAll(taskList);
      System.out.println(exec.submit(callableTask).get());
      runningServer.get();
    } catch (InterruptedException ex) {
      Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
    } catch (ExecutionException ex) {
      Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
    }
    exec.shutdown();
  }
}

