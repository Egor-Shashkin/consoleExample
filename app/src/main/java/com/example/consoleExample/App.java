/*
 * This source file was generated by the Gradle 'init' task
 */
package com.example.consoleExample;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.IOException;
import static java.lang.System.exit;
import java.net.ServerSocket;
import java.net.SocketTimeoutException;
import java.util.Scanner;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.cli.*;




public class App {
  static Gson gson = new GsonBuilder().setPrettyPrinting().create();
  static Scanner scan = new Scanner(System.in);
  static JsonActions jAct = new JsonActions();
  static AtomicInteger reservations = new AtomicInteger(0);

    
    
    
  public static void main(String[] args) throws IOException {
  //--------------------- initializing variables -----------------------------//
    AppConfig config = new AppConfig();
    Options options = config.configureOptions();
    config.optionsExecution(options, args);
    //when get more connection attempts than max number of server threads it throws SocketException
    //exec is used for running server
    ExecutorService exec = Executors.newFixedThreadPool(4);
    //clientExec is used to artificially make clients
    ExecutorService clientExec = Executors.newFixedThreadPool(5);
    Integer port = 7777;
    int serverTimeout = 15000;
    ServerSocket serverSocket = new ServerSocket(port);
    serverSocket.setSoTimeout(serverTimeout);
    FileWorker worker = new FileWorker();
    Lock lock = new ReentrantLock();
    
    Runnable startServer = () -> {
      while (true) {
        lock.lock();
        try {

        System.out.println("waiting for connection");
        exec.submit(new ServerThread(port, serverSocket, serverSocket.accept(), worker));

        } catch (SocketTimeoutException ex) {
          if (reservations.get() == 0 ) {
          System.out.printf("no new connection attempts detected in last %s seconds%n"
                  + "shutting down the server", TimeUnit.MILLISECONDS.toSeconds(serverTimeout));
          try {
            serverSocket.close();
            break;
          } catch (IOException ex1) {
            Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex1);
            exit(1);
          } 
          }else System.out.printf("tried to close server because of timeout. reservations = %s%n", reservations.get());

        } catch (IOException ex) {
          Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
          lock.unlock();
        }
      }
    };

    
  //------------------------ running program ---------------------------------//
    
    //starting server
    Future<?> runningServer = exec.submit(startServer);
    
    
    //artificially adding clients
    for (int i = 0; i < 5; i++){
        clientExec.submit(new ClientThread(port, String.valueOf(i)));
    }
    
    //checking if server is down then shutting down
    try {
      runningServer.get();
    } catch (InterruptedException ex) {
      Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
    } catch (ExecutionException ex) {
      Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
    }
    exec.shutdown();
    clientExec.shutdown();
  }
}

